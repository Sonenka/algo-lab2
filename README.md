# Лабораторная работа №2

### Описание работы
Даны прямоугольники на плоскости с углами в целочисленных координатах ([1..109],[1..109]).
Требуется как можно быстрее выдавать ответ на вопрос: «Скольким прямоугольникам принадлежит точка (x,y)?». При этом подготовка данных должна занимать мало времени.


### Цели лабораторной работы
- Реализовать три разных решения задачи
- Выяснить при каком объеме начальных данных и точек какой алгоритм эффективнее.

---
### Алгоритм перебора
```Python
def simple_search(rectangles, points):
    occurrence = [0] * len(points)

    for i in range(len(points)):
        x, y = points[i]

        for rectangle in rectangles:
            x1, y1, x2, y2 = rectangle

            if (x1 <= x < x2) and (y1 <= y < y2):
                occurrence[i] += 1
    return occurrence
   ```

**Сложность:**

Препроцессинг: О(1).
Поиск: O(M * N), где N - количество прямоугольников, M - количество точек.

---
### Алгоритм на карте

Препроцессинг: O(N^3)
* Сжимаем координаты всех угловых точек прямоугольников по осям x и y. Сжатие заключается в том, что мы присваиваем каждой уникальной координате порядковый номер.
* Создаем карту (матрицу) размером количество сжатых точек по оси x на количество сжатых точек по оси y.
* Заполняем карту следующим образом: обходим все прямоугольники и увеличиваем на единицу значение в ячейке карты, соответствующей сжатым координатам проекции каждого прямоугольника.

Поиск: O(M * logN), где N - количество прямоугольников, M - количество точек.
* Для каждой точки запроса выполняем следующие шаги:
    * С помощью бинарного поиска находим сжатые координаты точки запроса по осям x и y.
    * Обращаемся к ячейке карты, соответствующей найденным сжатым координатам.
    * Значение в этой ячейке карты будет равно количеству прямоугольников, которые содержат точку запроса.

```Python
def create_map(rectangles):
    set_x, set_y = set(), set()

    for rectangle in rectangles:
        set_x.add(rectangle[0])
        set_x.add(rectangle[1])
        set_x.add(rectangle[2])
        set_x.add(rectangle[3])

    set_x, set_y = sorted(set_x), sorted(set_y)

    matrix_map = []
    for y in set_y:
        row = [0 for _ in range(len(set_x))]
        matrix_map.append(row)

    for r in rectangles:
        x1, x2 = find_pos(set_x, r[0]), find_pos(set_x, r[2])
        y1, y2 = find_pos(set_y, r[1]), find_pos(set_y, r[3])

        for i in range(y1, y2):
            for j in range(x1, x2):
                matrix_map[i][j] += 1

    return matrix_map, set_x, set_y


def map_algorithm(matrix_map, points, set_x, set_y):
    result = []

    for point in points:
        pos_x, pos_y = find_pos(set_x, point[0]), find_pos(set_y, point[1])

        if pos_x == -1 or pos_y == -1:
            result.append(0)
        else:
            result.append(matrix_map[pos_y][pos_x])
            
    return result
```
---
### Алгоритм на дереве

Препроцессинг: O(N * logN)
* Сжимаем координаты всех угловых точек прямоугольников по осям x и y.
* Создаем дополнительную структуру Event, которая содержит начало или конец существования прямоугольника, а также сжатые координаты соответствующих точек.
* Строим пустое дерево отрезков на сжатых координатах.
* Добавляем в дерево отрезков персистентные узлы, используя события из структуры Event.

Поиск: O(M * logN), где N - количество прямоугольников, M - количество точек.

* Для каждой точки запроса выполняем следующие шаги:
    * С помощью бинарного поиска находим сжатые координаты точки запроса по осям x и y.
    * Находим нужный корень дерева отрезков по сжатым координатам точки запроса.
    * Осуществляем обход по дереву отрезков до нужного листа, используя сжатые координаты точки запроса.
    * Значение в листе дерева отрезков будет равно количеству прямоугольников, которые содержат точку запроса.


```Python
def build_persistent_segment_tree(rectangles, compress_x, compress_y):
    hits = []
    if not rectangles:
        return None

    for r in rectangles:
        begin_y = find_pos(compress_y, r[1])
        end_y = find_pos(compress_y, r[3])

        hits.append(Hit(r[0], begin_y, end_y - 1, 1))
        hits.append(Hit(r[2], begin_y, end_y - 1, -1))
    hits.sort(key=lambda hit: hit.x)

    roots = []
    root = build_tree(0, len(compress_y) - 1)

    end_x = hits[0].x
    for hit in hits:
        if end_x != hit.x:
            roots.append(root)
            end_x = hit.x
        root = insert(root, hit.begin_y, hit.end_y, hit.status)
    roots.append(root)
    return roots

def tree_algorithm(points, compress_x, compress_y, roots):
    answer = []
    if roots is None:
        return answer

    for p in points:
        pos_x, pos_y = find_pos(compress_x, p[0]), find_pos(compress_y, p[1])

        if pos_x == -1 or pos_y == -1:
            answer.append(0)
        else:
            answer.append(get_count(roots[pos_x], pos_y))
    return answer
```

---

### Генерация прямоугольников и точек:

```Python
def generate_data(n_rectangles, n_points):
    rectangles = []
    for i in range(n_rectangles):
        x1, y1, x2, y2 = 10 * i, 10 * i, 10 * (2 * n_rectangles - i), 10 * (2 * n_rectangles - i)
        rectangles.append((x1, y1, x2, y2))

    points = []
    for i in range(n_points):
        x = (i * 313) ** 31 % (20 * n_points)
        y = (i * 233) ** 31 % (20 * n_points)
        points.append([x, y])

    return rectangles, points
 ```

### Данные для тестирования:

- Количество прямоугольников: `2^i`, при `0<=i<=11`

- Количество точек: `2^i`, при `0<=i<=11`


### Измерение времени подготовки:

![](/graphics/prep.png)


Когда количество прямоугольников растет, время выполнения алгоритма на карте резко увеличивается. 
Это происходит из-за высокой асимптотической сложности построения карты - O(N^3).
В худшем случае алгоритму может потребоваться выполнить N итераций по всей матрице размером N x N.
Хотя построение персистентного дерева на небольших наборах данных занимает примерно столько же времени,
что и построение карты, алгоритм на дереве демонстрирует значительно более медленный рост времени выполнения с ростом количества данных.
Это означает, что алгоритм на дереве может эффективно выполнять предварительную обработку даже для больших наборов прямоугольников, в отличие от алгоритма на карте.


### Измерение времени поиска ответа:

![](/graphics/search.png)

На небольших наборах данных алгоритм полного перебора может иметь
небольшое преимущество, но оно настолько незначительно, что им
можно пренебречь. При увеличении количества прямоугольников
алгоритм полного перебора становится очень неэффективным, а
алгоритмы с предварительной обработкой данных остаются
относительно стабильными.
Алгоритм на карте превосходит алгоритм на дереве по эффективности,
хотя оба имеют одинаковую теоретическую сложность. Это связано с тем,
что алгоритму на дереве требуется выполнять дополнительный бинарный
поиск и обход по дереву, что приводит к более высокому коэффициенту
перед логарифмом по сравнению с алгоритмом на карте.


### Измерение общего времени:

![](/graphics/all.png)

График итогового времени ясно показывает, что алгоритм
на карте существенно медленнее других алгоритмов. Хотя
он может быстро находить решения, его производительность
падает при обработке примерно сотни прямоугольников,
что делает его менее эффективным, чем алгоритм полного перебора.
А вот алгоритм на дереве отличается большей
стабильностью и лучшей производительностью, особенно
при работе с большими наборами данных.

---

## Вывод
Алгоритм полного перебора лучше всего подходит для небольших наборов данных, 
поскольку он не требует предварительной подготовки данных. Алгоритм на карте
обеспечивает удовлетворительную производительность для небольшого количества
прямоугольников. Алгоритм на персистентном дереве отрезков демонстрирует
наилучшую производительность при работе с большими наборами данных.